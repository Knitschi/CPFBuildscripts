/**
\defgroup CPFBuildscriptsGroup CPFBuildscripts

\brief A package that provides python scripts for simplifying the CMake calls of CPF projects.

The package provides four python scripts that can be used for configuring and building a CPFCMake project.
CMake projects usually require calls to CMake to generate makefiles and build the project. Depending on
the project, the calls can require quite a list of arguments. The python scripts provided by the
CPFBuildscripts package use the knowledge about the structure of the CPF project to reduce the length
of those commands. It is therefore highly recommended to use the CPFBuildscripts package in combination
with the CPFCMake package.
*/



//##########################################################################################
/**
\page BuildScripts

# Build Scripts #

The CppCodeBase provides three python scripts that wrap underlying calls to CMake in order
to reduce the amount manually stated command line arguments. These scripts and their function
are described here.

## <tt>0_Configure.py</tt> ##

This script takes an arbitrary configuration name as its main Argument. It can take additional
definitions of CMake variables as optional arguments.

\code{.bat}
0_Configure.py VS2015 --DHUNTER_ROOT="C:/MyHunterLibs" --DCPPCODEBASE_TEST_FILES_DIR=="C:/Temp"
\endcode

calling the script generates the file \c Configuration/\<configuration\>.cmake where \c \<configuration\>
would be \c VS2015 in the given example. This file ccbContains the initial values of the mayor cmake cache variables
of the project. The values of the variables can be initialized by giving the \c --D options. The \c --D option
is mainly intended to be used on the build-server. In a local development loop it is probably more convenient
to generate a default configuration file without giving any \c --D options and then change the values of the variables 
by opening the file in a text editor.

In contrast to the \c CMakeCache.txt file which fulfills a very similar role, the \c \<configuration\>.cmake file
is kept outside the build tree. This allows deleting the complete build tree without loosing the manually set 
configuration.


## <tt>1_Generate.py</tt> ##

This script calls cmake to generate the 'make-files' for a given configuration. The script takes a configuration
name that was defined by a call to the \c 0_Configure.py script as its only argument.

\code{.bat}
1_Generate.py VS2015
\endcode

This call will generate the build tree root directory under \c Generated/\<configuration\>. It will also initialize
the cmake cache variables with the values from the configuration file. This means that previously made changes to
an exiting \c CMakeCache.txt file are lost when calling this script with the \c \<configuration\> argument.
The \c \<configuration\> argument can be omitted when there is only one \c Configuration/\<configuration\>.cmake
file available or if only one configuration has a build directory with an existing \c CMakeCache.txt file.
When the \c \<configuration\> argument is given, the script will clear the build tree before executing cmake.

Note that the first run of this script will trigger the hunter package manager to download and build the dependencies.


## <tt>2_Make.py</tt> ##

This script calls <tt>cmake --build</tt> in order to compile one of the targets contained in the CppCodeBase. The script
takes as main argument the \c \<configuration\> that should be build. Before this can be done, you must have run 
\c 1_Generate.py for that configuration. The script can take the optional argument <tt>--target \<target_name\></tt> and
the optional argument <tt>--config \<config_name\></tt>. 

\code{.bat}
2_Make.py VS2015 --target pipeline --config Release
\endcode

The main \c \<configuration\> argument can be omitted if only one configurations \c CMakeCache.txt file is available.
When the argument is omitted, cmake will execute an incremental build.

The \c --target option can be used to specify a certain target that shall be build. This typically is the \c pipeline target, which will build all available targets. 
If no \c --target option is given, the default target is built, which ccbContains only building the binary targets.

The \c --config option is only relevant when using a multi-configuration generator like Visual Studio. In this case the value of this
argument could be \c Release or \c Debug. If the option is omitted, the \c Debug configuration is build. Do not confuse this compile
configuration with the project configuration set with the \c 0_Configure.py script.


# Notes on the configuration file mechanism. #

The custom mechanism with the extra configuration file distinguishes the work-flow of the CppCodeBase from the
standard cmake command-line work-flow, where the configure and generate step are executed at the same time.
Using the CMake-Gui provides a similar work-flow, where the \c CMakeCache.txt file serves as the file
that defines the local configuration.

Having an extra configuration file creates some duplication. The extra configuration step may 
also be unexpected to developers who expect the normal cmake behavior.

However, in my experience the need to delete the complete build tree is quite common. Mainly
when making changes to the cmake code. In these cases it is quite annoying to reconfigure the
project by giving a possibly long list of cumbersome variables. In these cases it is nice to
have the configuration stored outside the build tree which removes the need for re-specifying
local settings whenever the build tree is deleted. The configuration file will typically contain
no internal variables and will therefore be much smaller then the \c CMakeCache.txt file.

When the mechanism with the extra configuration file was implemented, I also tried to
keep the \c CMakeCache.txt file out of the build tree by setting the \c CMAKE_CACHEFILE_DIR
variables. These attempts did not succeed.
*/
